#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math

DATA_SIZE = 1375

class Sender:
    """
    Handles sending messages to a specified host and port for a UDP-based messaging system,
    managing acknowledgments, and implementing a sliding window protocol for flow control. 

    It reads input from standard input, sends messages while maintaining a window size, 
    and handles received acknowledgments to adjust the window size dynamically. 
    The run method orchestrates the sending and receiving of messages, 
    ensuring that the sender operates efficiently until all messages are sent and acknowledged.
    """
    def __init__(self, host, port):
        """
        Initialize host, port, and other default variables for messaging system.
        """
        self.host = host
        self.port = int(port)
        self.log("Sender starting up using port %s" % self.port)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))
        self.waiting = False

        self.remote_host = None
        self.remote_port = None
        
        self.latency = 1
        self.window_size = 4
        self.rt_start = 0
        self.done = False
        self.inFlight = []
        self.totalSent = 0
        self.received = []
        self.more = True

    def log(self, message):
        """
        Write the given message to standard error.
        """
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, message):
        """
        Send the given message to address and capture time.
        """
        self.log("Sending message '%s'" % json.dumps(message))
        self.socket.sendto(json.dumps(message).encode("utf-8"), (self.host, self.port))
        self.rt_start = time.time()

    def recv(self, socket):
        """
        Receive from given socket and return the received json message or None if invalid.
        """
        socket.settimeout(self.latency)
        try:
            data, addr = socket.recvfrom(65535)
        except:
            return None

        # Grab the remote host/port if we don't already have it
        if self.remote_host is None:
            self.remote_host = addr[0]
            self.remote_port = addr[1]

        # Make sure we're talking to the same remote host
        if addr != (self.remote_host, self.remote_port):
            self.log("Error:  Received response from unexpected remote; ignoring")
            return None
        else:
            self.log("Received message %s" % data)
            return json.loads(data.decode("utf-8"))
        
    def send_input(self):
        """
        Sends in flight messages (messages which have yet to be acknowdledged).

        Uses a sliding window to control the sending rate.
        """
        for msg in self.inFlight:
            self.send(msg)
        while len(self.inFlight) < self.window_size:
            data = sys.stdin.read(DATA_SIZE)
            if len(data) == 0:
                self.more = False
                self.waiting = True
                break
            else:
                msg = { "type": "msg", "data": data, "seq": self.totalSent }
                self.send(msg)
                self.inFlight.append(msg)
                self.totalSent += 1
        self.waiting = True
            
    def recv_ack(self):
        """
        Receive acknowledge messages and remove from in flight messages when message
        safely transmitted.

        Updates window size given how many acknowledgements received.
        """
        thresh = 0
        while len(self.inFlight) > 0:
            data = self.recv(self.socket)
            if self.latency >= 1: self.latency = (time.time() - self.rt_start)
            if data:
                if (data == 'done'):
                    self.done = True
                    self.inFlight.remove('done')
                elif (data not in self.received):
                    self.received.append(data)
                    for msg in self.inFlight:
                        if msg['seq'] == data['seq']: self.inFlight.remove(msg)
                    thresh += 1
            else:
                break
        if thresh == self.window_size:
            self.window_size = max(self.window_size * 2, 1)
        else:
            self.window_size = max(self.window_size - 1, 1)
        self.waiting = False

    def run(self):
        """
        Runs the Sender in UDP-style messaging system.
         
        - Sends messages
        - Receives acknowledgments that have been sent,
        - Retransmits when messages drop
        - Exits when no packets are currently in flight and no data is left to send.

        """
        while True:
            sockets = [self.socket, sys.stdin] if not self.waiting else [self.socket]
            
            socks = select.select(sockets, [], [], 0.1)[0]
            
            for conn in socks:
                # Receives any acknowledgments that have been sent
                if conn == self.socket:
                    self.recv_ack()
                    
                # Sends a portion of the remaining input based on the window size
                elif (conn == sys.stdin):
                    self.send_input()
                    
            if (time.time() - self.rt_start >= self.latency + 0.1):
                self.send_input()
            
            # Exits if no packets are currently in flight and no data is left to send
            if (len(self.inFlight) == 0) & (not self.more):
                if (self.done):
                    self.log("All done!")
                    sys.exit(0)
                else:
                    self.send('done')
                    self.inFlight.append('done')
                    self.waiting = True

        return

if __name__ == "__main__":
    """
    Gathers host and port arguments. Then, creates and runs the Sender.
    """
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help="Remote host to connect to")
    parser.add_argument('port', type=int, help="UDP port number to connect to")
    args = parser.parse_args()
    sender = Sender(args.host, args.port)
    sender.run()
